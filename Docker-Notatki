Docker - pozwala tworzyc wiele aplikacji na jednym serwerze, ktore sa niezalezne, wyilizowane, ktore moga ze soba rozmawiac, ale kazdy jest zamknienty w swojej osobniej prszestrzeni.
Nie musimy instalować wielu innych aplikacji i bibliotek na jednym komputerze, ponieważ dzięki Dockerowi możemy umieścić je wszystkie w kontenerach.
Obrazy - sa jak klassy w programmowaniu objektowym, mamy klassy z ktorych mozemy tworzyc instancje(containery). Obrazy sa odpowiedniki tych klass, a Containery sa odpowiedniki tych instancji

##Architektura Dockera 
1.Najpierw laczymy sie z naszego Clienta na Docker Host
2.Docker Deamon laczy sie z Rejestrem
3.Docker Deamon sprawdza w cache czy jest nasz obraz - warunek true jak jest to wtedy korzysta z tego lokalnego obrazu i na jego podstawie moze sobie utworzyc container
jak nie to pobiera z rejestru zdalnego bardzo czesto to moze byc DockerHub, ale rowniez i jakis inne zrodlo.Pobieramy obraz i Docker cachue obraz na naszym lokalnym komputerze, a nastepnie na jego podstawie mozemy tworzyc sobie container
Moze zazadzac naszymi obrazami i containerami z poziomu Cleinta
Mozna rowniez podpinac pod containery nasze dyski i tam bede odkladane nasze danne
Najpopuilarniejszy rejestr Dockera - DockerHub, tam jest massa udostopnionych obrazow publicznie i mozemy korzystac za darmo
Rejestry mozna tworzyc wlasne, ktore beda przychowywac nasze obrazy

---

##Roznica miedzy Maszyna Virtualna, a Dockerem

##Maszyna Virtualna
Na maszynie Virtualnej mamy:
Hypervisor
Host OS: Moze to byc nasz komputer lokalny, server
Infrastrukture
Opragromowanie
Systemy operacyjne: Na nich pozniej sa tworzone te aplikacje
Aplikacje

##Minusy Maszyny Virtualnej:
Zazrzadzanie pamiecia
Zasoby Hosta, jesli ma kilka takich Maszyn Virtualnych

##Docker
Docker sa dogaduje sie z naszym systemem operacyjnym i wszystkie aplikacje i biblioteki uruchumaine sa bezposrednio na naszym systemie operacyjnym, na komputerze na jakim jest zainstolowany Docker
Dzieki czemu uruchamienie aplikacji jest zdecydowanie szybsze, wygodniejsze, zazadzanie containerami
Na Dockerze mamy: 
Infrastrukture
Host OS + Docker
Opragromowanie
Aplikacje

##Minusy Dockera:
Nie mozemy zrobic SnapShot kiedy zamykamy container, tracimy co jest w pamieci 
Po zastopowaniu containera pamiec jest czyszczona, po uruchomieniu go startuje na nowo

##Konteinery LXC
LXC - Linux Containers, to metoda wirtualizacji na poziomie systemu operacyjnego sluzaca do uruchomianiu wielu izolowanych systemow Linus na Hoscie

---

###Podsumowanie 

z Dockera korzystamy poniewaz: 
Dzieki niemu uzysujemy porzadek
Mozemy odizolowac aplikacje
Mozemy odizolowac srodowiska
W lepszy sposob zazadzac na komputerze, serveze tym co na nim sie znajduje
Ulatwia caly process wytworzenia opragromowania, bo ulatwiamy kwestie zwiazane z testowaniem, wysylamy wybramy obraz, testery tworza wlasny container, sprawdzaja czy jest dobrze czy zle
Nie trzeba tworzyc miliona Maszyn Virtualnych


##Instalacja Dockera i WSL2

##WSL2
1.Odpalic PowerShell w trybie admin
2.Wpisac w PowerShell wsl --install
3.Jesli po restartu komputera sie nie zainstalowal sie Ubuntu, trzeba wpisac wsl.exe --list --online
4.Wybrac odpowiedni system albo program i wpisac wsl.exe --install "nazwa programmu/systemu"


##Docker
1.Pobrac plik ze strony: https://docs.docker.com/desktop/setup/install/windows-install/
2.Odpalic plik i zaczekac jak sie rozpakuje plik i zainstaluje sie
3.Przejsc kroki w instalatorze Dockera

##Jak odpalic pierwszy container
1.Zrobic git clone przez PowerShell, przyklad: git clone https://github.com/docker/welcome-to-docker
2.Robimy obraz - docker build -t welcome-to-docker .
3.Wejsc w zakladki images, klikamy na nazwe obraza, po prawej stronie u gory bedzie przcisk Run
4.Wpisujemi port
5.Wygeneruje sie link do strony 
6.Wpisujemy localhost:"port" !!Wazne wejsc na port jaki wpisalismy wczesniej!!


##Komendy Docker
docker --version - sprawdzic versje Dockera
docker iamges - Wyswietlaja sie obrzy jakie sa dostepne 
dokcer container ls -a - Wyswietlaja sie containery, containery jakie sa dostepne na naszym Dockerze
docker start "poczatek id container" - Odpalic container, wystarczy napisac poczatek id containera 
docker pull "nazwa obrazu:versja" - pobrac obraz
docker stop my-apache-app - wylaczyc container
docker rm "nazwa obraza" - usunancz container
docker exec -it "id container" /bin/sh - wejsc do srodka, zeby moc zmieniac container, po wejscu mozna wpisac ls - zobaczyc pliki
cd "nazwa_katalogu"   - przejść do katalogu
cd .. - przejść do katalogu nadrzędnego (wyjść o poziom wyżej)
vi index.html - otworzyć / edytować plik index.html
Ctrl + C :wq - wyjsc z edycji pliku
exit - wyjsc do pozioma Ubuntu
docker commit "nazwa containera "nazwa uzytkownika"/app:version_1 - zrobic commit
docker history "nazwa uzytkownika"/app:version_1 - zobaczyc historie zmian

---

###Obrazy i Containery
##Warswy obrazow
Kernel - jest to jadro Linuxa, z ktorego korzysta Docker. Dlatego bylo istotne zainstalowa WSL2, zeby docker mog korzystac tego jadra
Alpine Linux - to jest wersja Linuxa bardzo uboga, okrajona do niezbendych rzeczy. Na nej mozemy sobie instalowac opragromowanie, biblioteki. Jest tez nazywany jako Base Image 
ADD glibc - jest to biblioteka
ADD apache - jest to jako webserver, srodowisko uruchominiowe
Kazda z Warstw ma swoje id, zeby moc w jakis sposob do nich sie odnosic, moc ich indefikowac, jest informacja co jest Parentem(Rodzicem tej warstwy). 


##Wartswa Containera
Wszystko bazuje na Ubuntu
Kazda warstwa ma swoje rozmiary, czyli np. 1 warstwa 0B, 2 wartstwa 1.895KB, 3 warstwa 194.5MB


##Pobranie Obrazu z DockerHub
httpd - Apache
docker pull httpd:2.4.66-alpine


##Uruchomenie containera
Apache chodzi na 80 porcie, tak jest domyslnie skonfigurowany, mozna rownie skonfigurowac na dowoln inny port
docker run -d --name my-apache-app -p 8080:80 httpd:2.4.66-alpine - uruchomi nasz obraz


##Edycja pliku
vi index.html 
Insert - Trzeba nacisnanc na klawiaturze zeby pisac
Delete - Trzeba nacisnancz na klawiaturze zeby usuwac
Ctrl + C :wq - wyjsc z edycji pliku
exit
docker commit my-apache-app ypayel/app:version_1 

---

###Tworzenie obrazu

1.Otworzyc Edytor Kodu
2.Utworzyc folder


3.Utworzyc plik naprzyklad index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker obraz</title>
</head>
<body>
    <h1>Docker cwicenia</h1>
</body>
</html>


4.Utworzyc DockerFile
# tworzymy nowy etap na podstawie obrazu bazowego
FROM httpd:2.4.66-alpine 


LABEL maintener="Zrob wlasny obraz"

# dodajemy plik lokalnie, dodajemy w tym przypadku tylko index.html
# ADD /usr/local/apache2/htdocs - w taki sposob dodaje sie caly DockerFile
ADD ./index.html /usr/local/apache2/htdocs

# EXPOSE nie nadaje portu, a tylko zwraca informacje ze powinien byc na porcie 80 w naszym przypadku
EXPOSE 80


5.Odpalic PowerShell
6.Wejsc do naszego folder naprzklad: cd C:\Users\User\Documents\GitHub\Docker_Cwicenia
7.Wpisujemy w terminalu: docker build -t "nazwa obrazu, bez tych nawiasow" "podajemy gdzie jest katolg w moim przypadku to bedzie tak: ./"
8.Wejsc do terminala Ubuntu, ale to rowniez mozna zrobic PowerShella oraz z aplikacji Docker Desktop
9.Wpisujemy takie polecenie w Ubuntu: docker run -d --name "wymyslic nazwe dla ubuntu" -p 80:80 "podajemy nazwe naszego obrazu, w moim przypadku to: cwiceniadocker:v1"

##Polecenia do edycji pliku 
ADD           – dodaje lokalne lub zdalne pliki i katalogi
ARG           – używa zmiennych na etapie budowania obrazu
CMD           – określa domyślne polecenie uruchamiane w kontenerze
COPY          – kopiuje pliki i katalogi
ENTRYPOINT    – określa główne polecenie (program) kontenera
ENV           – ustawia zmienne środowiskowe
EXPOSE        – opisuje, na jakich portach nasłuchuje aplikacja
FROM          – tworzy nowy etap budowy na podstawie obrazu bazowego
HEALTHCHECK   – sprawdza stan zdrowia kontenera po uruchomieniu
LABEL         – dodaje metadane do obrazu
MAINTAINER    – określa autora obrazu
ONBUILD       – definiuje instrukcje wykonywane, gdy obraz jest używany w innym buildzie
RUN           – wykonuje polecenia podczas budowania obrazu
SHELL         – ustawia domyślną powłokę (shell) obrazu
STOPSIGNAL    – określa sygnał systemowy do zatrzymania kontenera
USER          – ustawia użytkownika i grupę
VOLUME        – tworzy punkt montowania wolumenu
WORKDIR       – zmienia katalog roboczy

##Podsumowanie
Jesli chemy budoawc obrazy nie modyfikujac conteinery renczne mozemy to robic za pomoca Dokcerfile

---

###Jak dziala dockerignore
Dockerignor pozwala ignorowac pliki, foldery, katalogi ktore nie powiiny znalesc sie w budydowanych obrazach

w  .dockerignore jesli chcemy z igronorowac jakis plik wpisujemu go nazwe w srodku plika
np: Dockerfile
i po kazdej zmianie trzeba utworyc nowa werjse

.* - jesli chcemy zeby wszystkie nazwy rozpaczajace z kropki byly ignorowane

##Dla czego warto korzystac z .dockerignore
Pomaga w dyzuch projektach ignorowac rozne biblioteki ktore nie sa potrzebne w dalszym korzystaniu np: node_mudeles, vendor.
Nie musimy ich wysylac do obrazu

##
RUN npn install - jak chcemy zeby na nowym obrazie juz byl zainstolowany npm
Plusy:
1.Nie musimy wysylac tych katalogow oraz wysylanie tych katalogow pod cza budownia, moze zajmowac duzo wiecej czasu
2.Wydajnosc
3.Mozemy wtedy uniknanc nie spojnosci dannych, nie spojnosci wersji
4.Dbamy o stabilnosc aplikacji i jakosc, amiejszamy ryzyko pojawiania sie bledow


FROM httpd:2.4.66-alpine 
LABEL maintener="Zrob wlasny obraz"
ADD . /usr/local/apache2/htdocs

RUN npm install
EXPOSE 80


###TAGI

Tagi sa potrzebne dla tego zeby - jak rozwia sie nasza aplikacja i jest duzo roznych versji albo obrazow moc ich rozronic i wedziec kiedy byly zrobione ostatnie zmiany

docker tag "id naszego obrazu" "nazwa naszego tagu" - mozemy nadawac po ID obrazu
docker tag "nazwa obrazu" "nowa nazwa obrazu" - mozemy nadawac po imieniu obrazu 


versja - 7.80.0
Pierwsza liczba: 7 - zmiany kluczowe
Druga liczba: 80 - zmiany mniejsze. mniej wazne, ktore nie wplywaja na dzialanie calej aplikacji 
Trzecia liczba: 0 - bag fiksy

docker build -t cwiceniadocker/praktyki:1.0.0-beta .
docker rmi "pelna nazwa obrazu" - usuwa obrazy


###Połączenie z dyskiem lokalnym i tworzenie Volume
Volume - służy do przechowywania danych w dłuższej perspektywie, niezależnie od cyklu życia kontenera.
Rowniez mozemy twrozyc Volumeny pod czas konfigurowania Conteinera

docker volume create test-volume - tworzymy volume

docker volume ls - mozemy sprawdzic wszytskie volume ktore istieja

docker volume rm "nazwa volume" - usuwa volume 

docker run -d --name test-cwicenia-2.0.0-beta_2 -p 82:80 -v app_volume:/app  cwiceniadocker/praktyki:2.0.0-beta - uruchumiamy nasz Container z przedziolonym Volume

mkdir logs - za pomoca mkdir mozemy tworzyc pliki w terminalu Containera

vi text.txt - otwiera plik text.txt w edytorze tekstowym vi.

cp text.txt ./logs/ - kopujemy text.txt w logs

WORKDIR /app - ustawiamy katalog roboczy w conteinerze, wszystkie polecenia beda wykonywane w obszarze tego katalogu
ADD index.html . - oznacza to ze plik index.html zostanie przezucony w plik w ktorym sie znajdujemy. W tym przypadku bedzie on w /app

##Volumeny nazwane i ananimowe 
Docker zazadza tymi Volumenami
docker run -d --name test-cwicenia-2.0.0-beta_2 -p 82:80 -v app_volume:/app  cwiceniadocker/praktyki:2.0.0-beta - wprzypadku tego Volumena jest on nazwany 
docker run -d --name test-cwicenia-2.0.0-beta_2 -p 82:80 -v /app  cwiceniadocker/praktyki:2.0.0-beta - wprzypadku tego Volumena jest on ananiomy

##Volumeny tworzone lokalnie na dysky
docker run -d --name test-cwicenia-2.0.0-beta_4 -p 85:80 -v D:/app:/app  cwiceniadocker/praktyki:2.0.0-beta - utworzenie volumena lokalnie na naszym komputerze


###Bazy dannych w Docker
Wersja Bazy powinna byc zblizona na Dockerze do ktorej mamy na serverze
---env "nazwa zmiennej srodowiskowej" - w ten sposob mozemy przekazywac konfiguracje, wartosci, 

Jak pobrac obraz mariadb:
$ docker run --detach --name some-mariadb --env MARIADB_USER="wasza nazwa uzytkownika" --env MARIADB_PASSWORD="wasze haslo" --env MARIADB_DATABASE="wasza baza --env MARIADB_ROOT_PASSWORD="wasze haslo do root" -p 3307:3306 mariadb:latest


###Sieci w Docker 
Network Drivers - w Dockerze to mechanizmy, ktore okreslaja, jak kontenery komunikuja sie ze soba i ze swiatem zewnetznym
bridge - Tworzy wirtualna prywatna siec na hoscie.Kontenery w tej sieci widza sie po nazwach. Kontenery maja wewnetrzne IP, Dostęp z zewnątrz tylko przez mapowanie portów
host - Kontener nie ma wlasniej sieci, uzywa dokladnie tej samej co system operacyjny. Brak mapowania portów, localhost kontenera = localhost hosta
none - Kontener nie ma zadnego interfejsu sieciowego. Brak internetu, brak komunikacji
overlay - Pozwala konteinerom na roznych maszynach dzialac jak w jednej sieci. Kontenery widza sie po nazwach, dziala ponad fizyczna siecia, wymaga Docker Swarm
macvlan - Kontener jak osobne urzadzenie w LAN. IP z DHCP lub statyczne, kontener widoczny w LAN, host i kontener domyslnie sie nie widza
ipvlan - Podobny do macvlan ale: mniej overheadu, lepsza wydajnosc, lepsza kontrola routingu. Duze srodowiska, cloud/data center, produkcja
ipvlan vs macvlan:
macvlan -> symuluje karte sieciowa
ipvlan -> uzywa IP, nie MAC

docker network create - -driver ipvlan test-ip - Utworzyc siec
docker network rm test-ip - Usunancz siec
docker inspect bridge - Mozemy sprawdzic informacje o sieci 
docker network disconnect "nazwa sieci" "nazwa kontenera" - usunacz z sieci kontener
docker network connect "nazwa sieci" "nazwa kontenera" - polaczyc kontener z siecia
##Wazne w komunikacji pomiedzy serverami nie mozna z pingowac po nazwie konteinera, ale jezeli siec jest utworzona przez nas uzytkownika pingowanie po nazwach kontenera jest mozliwe
Czyli jesli mamy podpiente kontenery do wlasnej sieci, ktora utworzyzylismy jest mozliwe pingowanie, jest pewnego rodzaju mapowaine nazw na te adressy IP


###Docker compose
Docker compose do czego sluzy - jest przepisem jak zbudowac sobie srodowisko zlozone z kilku kontenerow.
Przyklad docker compose jest takim pzrepisem jak ugotowac ziemniaki, schabowy i mizeria.
W przsypadku - z ziemniakami to bedzie baza dannych
Kotletem schabowym - bedzie PHP i Laravel aplikacja
Mizeria - web server

##Jak utworzyc plik Docker compose
docker-compose.yml
version: "3,9"

services:
    database:
        container-name: shop-yt-db
        image: mariadb:latest
        ports: 
            -3307:3306
        environment:
           - MYSQL_DATABASE="nazwa bazy ablo mozna ${DB_DATABASE}"
           - MYSQL_USER="nazwa uzytkownika ablo mozna ${DB_USERNAME}"
           - MYSQL_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
           - MYSQL_ROOT_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
        volumes:
            - shop-yt-volume:"sciezka do volumena" /var/lib/mysql
        networks:
            - shop-yt-network
volumes:
    shop-yt-volume:

networks:
shop-yt-network
driver: bridge

##Jak odpalic docker-compose w terminalu
docker-compose up -d


##Aplikacja Laravelowa jak zrobic
1.Tworzymy Dockerfile
2.Dodac w Docker compose:
3.Uzupelnic Dockerfile

Dockerfile
From php:8.0

RUN apt-get update -y
RUN docker-php-ext-install pdo pdo_mysql - pobieramy biblioteki ktore nam sie przydadza

WORKDIR /var/www
COPY ..

COPY --from=composer:"versja ktora mamy" /usr/bin/composer /usr/bin/composer - coposer --version (w taki sposob mozna sprawdzic wersje)


ENV PORT=8000 - utwrozymy zmienna 
ENTRYPOINT ["docker/entrypoint.sh"]



4.Uzupelniamy plik entrypoint.sh
#!/bin/bash

composer install --no-interaction --no-progress

php artisan migrate:fresh --seed - zasilenie bazy dannymi testowymi 
php artisan cache:clear
php artisan config:clear
php artisan route:clear
php artisan serve --port=$PORT --host=0.0.0.0 - port taki sam jak zdefiniowalismy w Dockerfile

exec docker-php-entrypoint "$@"


5.Uzupelnic docker-compose.yml
docker-compose.yml
version: "3,9"

services:

----
!!!!Krok 2
    php:
        container_name: shop-yt
----


----
!!!!Krok 5
        build:
            context: .
        ports:
            - 8000:8000
        volumes:
            - ./:/var/www
        network:
            - shop-ty-network
----


    database:
        container-name: shop-yt-db - Trzeba wpisac w plik env w nazwe hosta czyli: HB_HOST=shop-yt-db
        image: mariadb:latest
        ports: 
            -3307:3306
        environment:
           - MYSQL_DATABASE="nazwa bazy ablo mozna ${DB_DATABASE}"
           - MYSQL_USER="nazwa uzytkownika ablo mozna ${DB_USERNAME}"
           - MYSQL_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
           - MYSQL_ROOT_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
        volumes:
            - shop-yt-volume:"sciezka do volumena" /var/lib/mysql
        networks:
            - shop-yt-network
volumes:
    shop-yt-volume:

networks:
shop-yt-network
driver: bridge



6.Odpalic aplikacje
docker-compose build --no-cache 
docker-compose up -d


7.Krok spawdzic czy dziala aplikacja 
localhost:8000



    php:
        container_name: shop-yt

docker-compose.yml
version: "3,9"

services:



    php:
        container_name: shop-yt

    database:
        container-name: shop-yt-db - Trzeba wpisac w plik env w nazwe hosta czyli: HB_HOST=shop-yt-db
        image: mariadb:latest
        ports: 
            -3306:3306
        environment:
           - MYSQL_DATABASE="nazwa bazy ablo mozna ${DB_DATABASE}"
           - MYSQL_USER="nazwa uzytkownika ablo mozna ${DB_USERNAME}"
           - MYSQL_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
           - MYSQL_ROOT_PASSWORD="haslo ablo mozna ${DB_PASSWORD}"
        volumes:
            - shop-yt-volume:"sciezka do volumena" /var/lib/mysql
        networks:
            - shop-yt-network
volumes:
    shop-yt-volume:

networks:
shop-yt-network
driver: bridge


##Uwagi, jak mamy customowy obraz, to musimy najpierw to zbudowac i dopiero pozniej uruchomic
docker-compose down - usuwa kontenery i siec i utrworzy pozniej na nowo
