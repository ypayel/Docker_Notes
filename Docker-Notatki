Docker - pozwala tworzyc wiele aplikacji na jednym serwerze, ktore sa niezalezne, wyilizowane, ktore moga ze soba rozmawiac, ale kazdy jest zamknienty w swojej osobniej prszestrzeni.
Nie musimy instalować wielu innych aplikacji i bibliotek na jednym komputerze, ponieważ dzięki Dockerowi możemy umieścić je wszystkie w kontenerach.
Obrazy - sa jak klassy w programmowaniu objektowym, mamy klassy z ktorych mozemy tworzyc instancje(containery). Obrazy sa odpowiedniki tych klass, a Containery sa odpowiedniki tych instancji

##Architektura Dockera 
1.Najpierw laczymy sie z naszego Clienta na Docker Host
2.Docker Deamon laczy sie z Rejestrem
3.Docker Deamon sprawdza w cache czy jest nasz obraz - warunek true jak jest to wtedy korzysta z tego lokalnego obrazu i na jego podstawie moze sobie utworzyc container
jak nie to pobiera z rejestru zdalnego bardzo czesto to moze byc DockerHub, ale rowniez i jakis inne zrodlo.Pobieramy obraz i Docker cachue obraz na naszym lokalnym komputerze, a nastepnie na jego podstawie mozemy tworzyc sobie container
Moze zazadzac naszymi obrazami i containerami z poziomu Cleinta
Mozna rowniez podpinac pod containery nasze dyski i tam bede odkladane nasze danne
Najpopuilarniejszy rejestr Dockera - DockerHub, tam jest massa udostopnionych obrazow publicznie i mozemy korzystac za darmo
Rejestry mozna tworzyc wlasne, ktore beda przychowywac nasze obrazy

---

##Roznica miedzy Maszyna Virtualna, a Dockerem

##Maszyna Virtualna
Na maszynie Virtualnej mamy:
Hypervisor
Host OS: Moze to byc nasz komputer lokalny, server
Infrastrukture
Opragromowanie
Systemy operacyjne: Na nich pozniej sa tworzone te aplikacje
Aplikacje

##Minusy Maszyny Virtualnej:
Zazrzadzanie pamiecia
Zasoby Hosta, jesli ma kilka takich Maszyn Virtualnych

##Docker
Docker sa dogaduje sie z naszym systemem operacyjnym i wszystkie aplikacje i biblioteki uruchumaine sa bezposrednio na naszym systemie operacyjnym, na komputerze na jakim jest zainstolowany Docker
Dzieki czemu uruchamienie aplikacji jest zdecydowanie szybsze, wygodniejsze, zazadzanie containerami
Na Dockerze mamy: 
Infrastrukture
Host OS + Docker
Opragromowanie
Aplikacje

##Minusy Dockera:
Nie mozemy zrobic SnapShot kiedy zamykamy container, tracimy co jest w pamieci 
Po zastopowaniu containera pamiec jest czyszczona, po uruchomieniu go startuje na nowo

##Konteinery LXC
LXC - Linux Containers, to metoda wirtualizacji na poziomie systemu operacyjnego sluzaca do uruchomianiu wielu izolowanych systemow Linus na Hoscie

---

###Podsumowanie 

z Dockera korzystamy poniewaz: 
Dzieki niemu uzysujemy porzadek
Mozemy odizolowac aplikacje
Mozemy odizolowac srodowiska
W lepszy sposob zazadzac na komputerze, serveze tym co na nim sie znajduje
Ulatwia caly process wytworzenia opragromowania, bo ulatwiamy kwestie zwiazane z testowaniem, wysylamy wybramy obraz, testery tworza wlasny container, sprawdzaja czy jest dobrze czy zle
Nie trzeba tworzyc miliona Maszyn Virtualnych


##Instalacja Dockera i WSL2

##WSL2
1.Odpalic PowerShell w trybie admin
2.Wpisac w PowerShell wsl --install
3.Jesli po restartu komputera sie nie zainstalowal sie Ubuntu, trzeba wpisac wsl.exe --list --online
4.Wybrac odpowiedni system albo program i wpisac wsl.exe --install "nazwa programmu/systemu"


##Docker
1.Pobrac plik ze strony: https://docs.docker.com/desktop/setup/install/windows-install/
2.Odpalic plik i zaczekac jak sie rozpakuje plik i zainstaluje sie
3.Przejsc kroki w instalatorze Dockera

##Jak odpalic pierwszy container
1.Zrobic git clone przez PowerShell, przyklad: git clone https://github.com/docker/welcome-to-docker
2.Robimy obraz - docker build -t welcome-to-docker .
3.Wejsc w zakladki images, klikamy na nazwe obraza, po prawej stronie u gory bedzie przcisk Run
4.Wpisujemi port
5.Wygeneruje sie link do strony 
6.Wpisujemy localhost:"port" !!Wazne wejsc na port jaki wpisalismy wczesniej!!


##Komendy Docker
docker --version - sprawdzic versje Dockera
docker iamges - Wyswietlaja sie obrzy jakie sa dostepne 
dokcer container ls -a - Wyswietlaja sie containery, containery jakie sa dostepne na naszym Dockerze
docker start "poczatek id container" - Odpalic container, wystarczy napisac poczatek id containera 
docker pull "nazwa obrazu:versja" - pobrac obraz
docker stop my-apache-app - wylaczyc container
docker rm "nazwa obraza" - usunancz container
docker exec -it "id container" /bin/sh - wejsc do srodka, zeby moc zmieniac container, po wejscu mozna wpisac ls - zobaczyc pliki
cd "nazwa_katalogu"   - przejść do katalogu
cd .. - przejść do katalogu nadrzędnego (wyjść o poziom wyżej)
vi index.html - otworzyć / edytować plik index.html
Ctrl + C :wq - wyjsc z edycji pliku
exit - wyjsc do pozioma Ubuntu
docker commit "nazwa containera "nazwa uzytkownika"/app:version_1 - zrobic commit
docker history "nazwa uzytkownika"/app:version_1 - zobaczyc historie zmian

---

###Obrazy i Containery
##Warswy obrazow
Kernel - jest to jadro Linuxa, z ktorego korzysta Docker. Dlatego bylo istotne zainstalowa WSL2, zeby docker mog korzystac tego jadra
Alpine Linux - to jest wersja Linuxa bardzo uboga, okrajona do niezbendych rzeczy. Na nej mozemy sobie instalowac opragromowanie, biblioteki. Jest tez nazywany jako Base Image 
ADD glibc - jest to biblioteka
ADD apache - jest to jako webserver, srodowisko uruchominiowe
Kazda z Warstw ma swoje id, zeby moc w jakis sposob do nich sie odnosic, moc ich indefikowac, jest informacja co jest Parentem(Rodzicem tej warstwy). 


##Wartswa Containera
Wszystko bazuje na Ubuntu
Kazda warstwa ma swoje rozmiary, czyli np. 1 warstwa 0B, 2 wartstwa 1.895KB, 3 warstwa 194.5MB


##Pobranie Obrazu z DockerHub
httpd - Apache
docker pull httpd:2.4.66-alpine


##Uruchomenie containera
Apache chodzi na 80 porcie, tak jest domyslnie skonfigurowany, mozna rownie skonfigurowac na dowoln inny port
docker run -d --name my-apache-app -p 8080:80 httpd:2.4.66-alpine - uruchomi nasz obraz


##Edycja pliku
vi index.html 
Insert - Trzeba nacisnanc na klawiaturze zeby pisac
Delete - Trzeba nacisnancz na klawiaturze zeby usuwac
Ctrl + C :wq - wyjsc z edycji pliku
exit
docker commit my-apache-app ypayel/app:version_1 

---

###Tworzenie obrazu

1.Otworzyc Edytor Kodu
2.Utworzyc folder


3.Utworzyc plik naprzyklad index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker obraz</title>
</head>
<body>
    <h1>Docker cwicenia</h1>
</body>
</html>


4.Utworzyc DockerFile
# tworzymy nowy etap na podstawie obrazu bazowego
FROM httpd:2.4.66-alpine 


LABEL maintener="Zrob wlasny obraz"

# dodajemy plik lokalnie, dodajemy w tym przypadku tylko index.html
# ADD /usr/local/apache2/htdocs - w taki sposob dodaje sie caly DockerFile
ADD ./index.html /usr/local/apache2/htdocs

# EXPOSE nie nadaje portu, a tylko zwraca informacje ze powinien byc na porcie 80 w naszym przypadku
EXPOSE 80


5.Odpalic PowerShell
6.Wejsc do naszego folder naprzklad: cd C:\Users\User\Documents\GitHub\Docker_Cwicenia
7.Wpisujemy w terminalu: docker build -t "nazwa obrazu, bez tych nawiasow" "podajemy gdzie jest katolg w moim przypadku to bedzie tak: ./"
8.Wejsc do terminala Ubuntu, ale to rowniez mozna zrobic PowerShella oraz z aplikacji Docker Desktop
9.Wpisujemy takie polecenie w Ubuntu: docker run -d --name "wymyslic nazwe dla ubuntu" -p 80:80 "podajemy nazwe naszego obrazu, w moim przypadku to: cwiceniadocker:v1"

##Polecenia do edycji pliku 
ADD           – dodaje lokalne lub zdalne pliki i katalogi
ARG           – używa zmiennych na etapie budowania obrazu
CMD           – określa domyślne polecenie uruchamiane w kontenerze
COPY          – kopiuje pliki i katalogi
ENTRYPOINT    – określa główne polecenie (program) kontenera
ENV           – ustawia zmienne środowiskowe
EXPOSE        – opisuje, na jakich portach nasłuchuje aplikacja
FROM          – tworzy nowy etap budowy na podstawie obrazu bazowego
HEALTHCHECK   – sprawdza stan zdrowia kontenera po uruchomieniu
LABEL         – dodaje metadane do obrazu
MAINTAINER    – określa autora obrazu
ONBUILD       – definiuje instrukcje wykonywane, gdy obraz jest używany w innym buildzie
RUN           – wykonuje polecenia podczas budowania obrazu
SHELL         – ustawia domyślną powłokę (shell) obrazu
STOPSIGNAL    – określa sygnał systemowy do zatrzymania kontenera
USER          – ustawia użytkownika i grupę
VOLUME        – tworzy punkt montowania wolumenu
WORKDIR       – zmienia katalog roboczy

##Podsumowanie
Jesli chemy budoawc obrazy nie modyfikujac conteinery renczne mozemy to robic za pomoca Dokcerfile

---

###Jak dziala dockerignore
Dockerignor pozwala ignorowac pliki, foldery, katalogi ktore nie powiiny znalesc sie w budydowanych obrazach

w  .dockerignore jesli chcemy z igronorowac jakis plik wpisujemu go nazwe w srodku plika
np: Dockerfile
i po kazdej zmianie trzeba utworyc nowa werjse

.* - jesli chcemy zeby wszystkie nazwy rozpaczajace z kropki byly ignorowane

##Dla czego warto korzystac z .dockerignore
Pomaga w dyzuch projektach ignorowac rozne biblioteki ktore nie sa potrzebne w dalszym korzystaniu np: node_mudeles, vendor.
Nie musimy ich wysylac do obrazu

##
RUN npn install - jak chcemy zeby na nowym obrazie juz byl zainstolowany npm
Plusy:
1.Nie musimy wysylac tych katalogow oraz wysylanie tych katalogow pod cza budownia, moze zajmowac duzo wiecej czasu
2.Wydajnosc
3.Mozemy wtedy uniknanc nie spojnosci dannych, nie spojnosci wersji
4.Dbamy o stabilnosc aplikacji i jakosc, amiejszamy ryzyko pojawiania sie bledow


FROM httpd:2.4.66-alpine 
LABEL maintener="Zrob wlasny obraz"
ADD . /usr/local/apache2/htdocs

RUN npm install
EXPOSE 80

